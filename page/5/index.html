<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/source/images/favicon.ico?v=7.1.2">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Hello world!">
<meta property="og:type" content="website">
<meta property="og:title" content="龙宇的博客小站">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="龙宇的博客小站">
<meta property="og:description" content="Hello world!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="龙宇的博客小站">
<meta name="twitter:description" content="Hello world!">





  
  
  <link rel="canonical" href="http://yoursite.com/page/5/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>龙宇的博客小站</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">龙宇的博客小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/技术教程/docker/2017-2-1-docker安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/02/01/技术教程/docker/2017-2-1-docker安装/" class="post-title-link" itemprop="url">docker 安装</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-01T00:00:00+08:00">2017-02-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 14:24:19" itemprop="dateModified" datetime="2019-06-28T14:24:19+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu-16-04"><a href="#ubuntu-16-04" class="headerlink" title="ubuntu 16.04+"></a>ubuntu 16.04+</h1><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<p>添加国内软件源的 GPG 密钥:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>向 source.list 中添加 Docker 国内软件源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure>

<p>更新 apt 软件包缓存，并安装 docker-ce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<p>启动 Docker CE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>将当前用户加入 docker 组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>退出当前终端并重新登录，测试 Docker 是否安装:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重新启动服务:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/17/技术教程/C++/2017-1-17-第十七章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/17/技术教程/C++/2017-1-17-第十七章/" class="post-title-link" itemprop="url">第十七章 标准库特殊设施</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-17T00:00:00+08:00">2017-01-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:06:59" itemprop="dateModified" datetime="2019-06-28T09:06:59+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h1><h2 id="tuple-类型"><a href="#tuple-类型" class="headerlink" title="tuple 类型"></a>tuple 类型</h2><p>tuple 可以装多个不同类型的成员。必须使用直接初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">int</span>, <span class="built_in">string</span>&gt; item&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">"str"</span>&#125;;   <span class="comment">//正确</span></span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">int</span>, <span class="built_in">string</span>&gt; item = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">"str"</span>&#125;;   <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"str"</span>);   <span class="comment">//用 make_tuple 初始化</span></span><br></pre></td></tr></table></figure>

<p>使用 get 这个标准库模板访问 tuple 的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = get&lt;<span class="number">0</span>&gt;(item);   <span class="comment">//返回 item 第一个成员</span></span><br></pre></td></tr></table></figure>

<p>只有两个 tuple 具有相同数量的成员时，我们才可以比较他们。一般情况下还必须是相同类型。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>RE 库定义在头文件 regex 中，包含多个组件：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>regex</td>
<td>表示一个正则表达式的类</td>
</tr>
<tr>
<td>regex_match</td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td>regex_search</td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td>sregex_iterator</td>
<td>迭代器匹配器，遍历一个 string 中所有匹配的字串</td>
</tr>
<tr>
<td>regex_replace</td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td>smatch</td>
<td>容器类，保存在 string 中搜索的结果</td>
</tr>
</tbody></table>
<p><strong>使用正则表达式库</strong></p>
<p>regex 使用的正则表达式语言默认是 ECMAScript，在 ECMAScript 中：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td>[[:alpha:]]</td>
<td>任意字母</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>任意字母或数字</td>
</tr>
<tr>
<td>\{d}</td>
<td>单个数字</td>
</tr>
<tr>
<td>\{d}{n}</td>
<td>n 个数字的序列</td>
</tr>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>+</td>
<td>一个或多个匹配</td>
</tr>
<tr>
<td>*</td>
<td>零个或多个匹配</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
</tr>
<tr>
<td>[^c]</td>
<td>任意不是 c 的字符</td>
</tr>
<tr>
<td>[]</td>
<td>里面字符中任意一个</td>
</tr>
<tr>
<td>[-. ]</td>
<td>短横或点号或空格（点号在 [ ] 中没有特殊含义）</td>
</tr>
<tr>
<td>？</td>
<td>表示 ？ 前面的组件是可选的</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
</tbody></table>
<p>注意：==\== 在 ECMAScript 和 C++ 中都是转义字符 ==\\.== 表示将 ==.== 转义为普通的点号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span>)</span></span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern, regex::icase)</span></span>;   <span class="comment">//icase 表示匹配时忽略大小写</span></span><br><span class="line">smatch results;   <span class="comment">//存储匹配结果</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"hello.Cpp"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (regex_search(str,results,r))&#123;   <span class="comment">//将第一个匹配成功的结果存储在 results 中，如果有匹配的返回 true</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//打印匹配的单词</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>smatch 表示 string 类型的输入序列，cmatch 表示字符数组序列:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmatch results2;</span><br><span class="line"><span class="keyword">if</span> (regex_search(<span class="string">"hello.Cpp"</span>, results2, r)) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results2.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匹配与 Regex 迭代器类型</strong></p>
<p>我们可以是以使用 sregex_iterator 来获取所有匹配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"[^c]ei"</span>)</span></span>;</span><br><span class="line">pattern = <span class="string">"[[:alpha:]]*"</span> + pattern + <span class="string">"[[:alpha:]]*"</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattern, regex::icase)</span></span>;</span><br><span class="line"><span class="built_in">string</span> test = <span class="string">"receipt freind theif receive"</span>;</span><br><span class="line"><span class="comment">//sregex_iterator 构造了两个迭代器，end_it 为空，起到尾后迭代器的作用</span></span><br><span class="line"><span class="keyword">for</span> (sregex_iterator it(test.begin(), test.end(), r), end_it; it != end_it; it++) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; it-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用子表达式</strong></p>
<p>正则表达式语法通常用括号表示子表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">"([[:alnum:]])+\\.(cpp|cxx|cc)$"</span>, regex::icase)</span></span>;   <span class="comment">//有两个子表达式</span></span><br><span class="line">cmatch results2;</span><br><span class="line"><span class="keyword">if</span> (regex_search(<span class="string">"hello.Cpp"</span>, results2, r)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; results2.str(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//打印整个模式对应的匹配：hello.Cpp</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results2.str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//打印第一个子表达式：hello</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results2.str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//打印第二个字表达式：Cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 regex_replace</strong></p>
<p>用符号 $ 后跟==子表达式==的索引号来表示一个特定的子表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"$2.$5.$7"</span>)</span></span>;   <span class="comment">//需要第2、5、7个子表达式，将号码格式改为 ddd.ddd.dddd</span></span><br><span class="line"><span class="built_in">string</span> phone = <span class="string">"(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ])?(\\d&#123;4&#125;)"</span>;   <span class="comment">// 第一个子表达式表示可选的左括号：(\\()？</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;</span><br><span class="line"><span class="built_in">string</span> number = <span class="string">"(908) 555-1800"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_replace(number, r, pattern) &lt;&lt; <span class="built_in">endl</span>;   为：<span class="number">908.555</span><span class="number">.1800</span></span><br></pre></td></tr></table></figure>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在头文件 random 中定义了：随机数引擎类（生成随机 unsigned 整数序列）、随机数分布类（调用引擎生成特定概率分布的随机数）。</p>
<p><strong>随机数引擎和分布</strong></p>
<p>大多数场合，随机数引擎的输出是不能直接使用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;   <span class="comment">//实例化一个引擎对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//用 e 生成一个随机数</span></span><br></pre></td></tr></table></figure>

<p>常把定义在头文件 ctime 中的系统函数 time 设置为种子，初始化引擎：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt; u(<span class="number">-5</span>, <span class="number">9</span>);   <span class="comment">//常常定义为 static</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;   <span class="comment">//time 作为种子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">" "</span>;   <span class="comment">//注意生成时是引擎传给分布</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他随机分布</strong></p>
<p>生成浮点数用 uniform_real_distribution&lt;&gt;,空 &lt;&gt; 表示默认生成 double 值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; u(<span class="number">-5</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>新标准定义了20中分布类型，normal_distribution 生成正态分布的浮点数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">normal_distribution&lt;&gt; u(<span class="number">4</span>, <span class="number">1.5</span>);   <span class="comment">//均值为 4，标准差 1.5</span></span><br></pre></td></tr></table></figure>

<p>bernoulli_distribution 分布不接受模板参数，默认以 0.5 的概率返回 true:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bernoulli_distribution u;</span><br><span class="line"><span class="function">bernoulli_distribution <span class="title">u1</span><span class="params">(<span class="number">.55</span>)</span></span>;   <span class="comment">//以 0.55 的概率返回 true</span></span><br><span class="line"><span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">bool</span> first = u(e);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/16/技术教程/C++/2017-1-16-第十六章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/16/技术教程/C++/2017-1-16-第十六章/" class="post-title-link" itemprop="url">第十六章 模板与泛型编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-16T00:00:00+08:00">2017-01-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:08:45" itemprop="dateModified" datetime="2019-06-28T09:08:45+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>模板是泛型编程的基础，一个模板就是一个创建类或者函数的蓝图或者公式。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><p><strong>函数模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::less;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//注意没有顿号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1,<span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (less&lt;T&gt;() (v1,v2)) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//使用标准库中的less函数比较不同类型的参数</span></span><br><span class="line">	<span class="keyword">if</span> (less&lt;T&gt;() (v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//实例化函数模板</span></span><br></pre></td></tr></table></figure>

<p>模板类型参数，在模板参数列表中 typename 与 class 没有什么不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">T</span> <span class="title">calc</span> (<span class="title">const</span> <span class="title">T</span>&amp;,<span class="title">const</span> <span class="title">U</span>&amp;);</span></span><br></pre></td></tr></table></figure>

<p>非类型模板参数，一个非类型参数表示一个值而非一个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>&#123;   <span class="comment">//N 与 M 表示数组的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>);</span><br></pre></td></tr></table></figure>

<p>函数模板和类模板成员函数的定义通常放在头文件中。</p>
<p>模板直到实例化时才会生成代码。</p>
<p>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能够正确工作，是调用者的责任。</p>
<p><strong>类模板</strong></p>
<p>定义在类模板之外的成员函数必须以关键字 template 开始，后接类模板参数列表。</p>
<p>在一个类模板的作用域中，我们可以直接使用模板名而不必指定模板实参。</p>
<p><strong>模板参数</strong></p>
<p>在模板内不能重用模板参数名。</p>
<p>C++ 假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式的告诉编译器该名字是一个类型。我们通过关键字 typename 来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span>&#123;   <span class="comment">//显示告诉编译器该名字是一个类型</span></span><br><span class="line">    <span class="keyword">if</span>(!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以为函数和类模板提供默认实参。</p>
<p>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;calss T = <span class="keyword">int</span>&gt; class Numbers &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v = <span class="number">0</span>): val(v)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;   <span class="comment">//空 &lt;&gt; 表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>

<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/15/技术教程/C++/2017-1-15第十五章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/15/技术教程/C++/2017-1-15第十五章/" class="post-title-link" itemprop="url">第十五章 面向对象编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-15T00:00:00+08:00">2017-01-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:07:40" itemprop="dateModified" datetime="2019-06-28T09:07:40+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="OOP-概述"><a href="#OOP-概述" class="headerlink" title="OOP 概述"></a>OOP 概述</h2><p>面向对象程序设计的核心思想是数据抽象、继承和动态绑定。</p>
<p>基类希望它的派生类各自定义适合自己的版本，此时基类就将这些函数声明成虚函数。</p>
<p>在派生类的函数后加 override，显式注明该函数改写了基类的虚函数。</p>
<p>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。函数的运行版本由实参决定，即在运行时选择函数的版本。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p><strong>定义基类</strong></p>
<p>基类通常在其成员函数的声明语句之前加上 virtual 显示的指出虚函数。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>派生类能访问公有成员而不能访问私有成员，protected 访问运算符允许派生类有权访问该成员，同时禁止其他用户访问。</p>
<p><strong>定义派生类</strong></p>
<p>我们能把派生类的对象当成基类对象来使用，我们也能将基类的指针或引用绑定到派生类对象中的基类部分上，通常称为派生类到基类的类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;   <span class="comment">//基类对象</span></span><br><span class="line">Bulk_quote bulk;   <span class="comment">//派生类对象</span></span><br><span class="line">Quote *p = &amp;item;   <span class="comment">//p 指向 Quote 对象</span></span><br><span class="line">p = &amp;bulk;   <span class="comment">//p 指向 bulk 的 Quote 部分</span></span><br><span class="line">Quote &amp;r = bulk;   <span class="comment">//r 绑定到 bulk 的 Quote 部分</span></span><br></pre></td></tr></table></figure>

<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生对象将被忽略掉。</p>
<p>基类向派生类不存在隐式类型转换。</p>
<p>派生类也必须使用基类的构造函数来初始化它的基类部分，每个类控制它自己的成员初始化过程。派生类对象不能直接初始化基类的成员。</p>
<p>在派生类的构造函数中，首先用基类的构造函数初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>
<p>派生类可以访问基类的公有成员和受保护成员。</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。</p>
<p>派生类的声明中，包含类名但是不包含它的派生列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote;   <span class="comment">//错误，不应包含它的派生列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span>   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>如果我们不希望其他类继承它，可以在类名后更一个关键字 final:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">fianl</span> &#123;</span> <span class="comment">/* */</span>&#125;;   <span class="comment">//NoDerived 类不能作为基类</span></span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>当我们使用==基类==的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果函数是虚函数，则直到运行时才会决定到底执行哪个版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">print_total(<span class="built_in">cout</span>,base,<span class="number">10</span>);   <span class="comment">//第二个参数出入的是引用，该函数中调用 Quote::net_price</span></span><br><span class="line">Bulk_quote derived;</span><br><span class="line">print_total(<span class="built_in">cout</span>,derived,<span class="number">10</span>);   <span class="comment">//调用 Bulk_quote::net_price</span></span><br></pre></td></tr></table></figure>

<p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用 virtual 关键字指出该函数的性质，然而并非必要。</p>
<p>当派生类的函数覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配，返回类型也必须与基类函数匹配。</p>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，编译器认为新定义的这个函数与基类中原有的函数是相互独立的，并没有覆盖基类中的版本，但这是坏习惯。</p>
<p>我们可以用 override 关键字来说明派生类中的函数是要覆盖基类中的虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override</span>;   <span class="comment">//正确：与基类匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> override</span>;   <span class="comment">//错误：基类中没有参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> override</span>;   <span class="comment">//错误：基类中 f3 不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> override</span>;   <span class="comment">//错误：基类中没有 f4 这个虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以把某个函数指定为 final,不允许之后的派生类覆盖该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">    <span class="comment">//从 B 继承 f2 和 f3，覆盖 f1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;   <span class="comment">//不允许后续的其他类覆盖 f1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;   <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;   <span class="comment">//错误：D2 已经将 f2 声明成 final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚函数使用默认参数，则基类和派生类中定义的默认实参最好一致。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>我们可以在函数后加 =0 定义成为==纯虚函数==，令类不能创建对象，含有的纯虚函数的类是抽象基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disv_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;   <span class="comment">//将继承类的函数定义为纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象基类不能创建对象，它的派生类必须覆盖纯虚函数才能创建对象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>派生类的成员和友元只能通过派生类对象访问派生类中的基类部分的受保护成员。</p>
<p>派生类列表中的访问说明符：继承自基类的成员在派生类中的类型。</p>
<p>每个类负责控制自己的成员访问权限，就像友元关系不能传递一样，友元关系也不能继承。</p>
<p>可以通过 using 改变个别成员的可访问性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base&#123;   <span class="comment">//Base 在 Derived 中是 private 的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;   <span class="comment">//改变基类中 size 成员的访问权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==注==：class 关键字默认私有继承，struct 关键字默认公有继承。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>派生类作用域位于基类作用域之内。成员名字先在派生类中查找，再在基类中查找。</p>
<p>派生类的成员将隐藏同名的基类成员，即使派生类成员和基类成员的形参列表不一致。我们可以通过作用域运算符类使用一个被隐藏的基类成员。</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重定义其他定义在基类中的名字。（==注==：这里区别覆盖与重定义）</p>
<p>成员函数无论是否是虚函数都能被重载，一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>如果我们删除一个指向派生类对象的基类指针，则需要把基类中的析构函数定义为虚析构函数。</p>
<p>派生类析构函数只负责销毁由派生类自己分配的资源。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当容器定义成基类类型时，可以把派生类类型对象放入容器，但是通过容器只能访问派生类类型对象的基类成员。</p>
<p>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是指针（智能指针更好），这些指针所知对象的动态类型可能是基类类型，也可能是派生类类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">havetopay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A类"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">havetopay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B类"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;A&gt;&gt; vec;   <span class="comment">//指向 A 类型的智能指针</span></span><br><span class="line">	vec.push_back(make_shared&lt;A&gt;());</span><br><span class="line">	vec.push_back(make_shared&lt;B&gt;());</span><br><span class="line">	vec.back()-&gt;havetopay();   <span class="comment">//注：调用的是 B 类的函数</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	vector&lt; A *&gt; vec;   //指向 A 类型的一般指针</span></span><br><span class="line"><span class="comment">	A a; B b;</span></span><br><span class="line"><span class="comment">	vec.push_back(&amp;a);</span></span><br><span class="line"><span class="comment">	vec.push_back(&amp;b);</span></span><br><span class="line"><span class="comment">	vec.back()-&gt;havetopay();   //注：调用的是 B 类的函数</span></span><br><span class="line"><span class="comment">	system("pause");</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/14/技术教程/C++/2017-1-14-第十四章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/14/技术教程/C++/2017-1-14-第十四章/" class="post-title-link" itemprop="url">第十四章 重载运算符与类型转换</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-14T00:00:00+08:00">2017-01-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:09:30" itemprop="dateModified" datetime="2019-06-28T09:09:30+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重载运算符与类型转换"><a href="#重载运算符与类型转换" class="headerlink" title="重载运算符与类型转换"></a>重载运算符与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>,<span class="keyword">int</span>);   <span class="comment">//错误，不能为 int 重定义内置的运算符</span></span><br></pre></td></tr></table></figure>

<p>重载运算符的优先级和结合律与对于的内置运算符保持一致。</p>
<p>调用一个重载的运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;   <span class="comment">//普通表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1,data2);   <span class="comment">//对非成员运算符的等价调用</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);   <span class="comment">//对成员运算符的等价调用</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>
<p>赋值（=）、下标（[]）、调用（()）和成员访问（-&gt;）运算符必须是成员。</p>
<p>具有对称性的运算符可能转换任意一段的运算对象，例如算术、相等性、关系和位运算符等通常是非成员函数</p>
<p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"word"</span>;</span><br><span class="line"><span class="built_in">string</span> t = s + <span class="string">"!"</span>;   <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">string</span> u = <span class="string">"hi"</span> + s;   <span class="comment">//如何 + 是 string 的成员，则产生错误</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中 “hi” + s 等价于 “hi”.operator+(s) ，”hi” 是 const char* 类型，根本就没有成员函数。</p>
<p>当且仅当 &lt; 的定义与 == 产生的结果一致时才定义 &lt; 运算符。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs) &#123;   <span class="comment">//重载赋值运算符，必须是成员函数</span></span><br><span class="line">	bookNo = rhs.bookNo;</span><br><span class="line">	units_sold = rhs.units_sold;</span><br><span class="line">	revenue = rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">//返回左侧运算对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>operator&lt;&lt; 一般要返回它的 ostream 形参。IO 运算符一般被声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::istream &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;in) &#123;   <span class="comment">//重载输入运算符，成员函数</span></span><br><span class="line">	in &gt;&gt; bookNo &gt;&gt; units_sold &gt;&gt; revenue;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item) &#123;   <span class="comment">//重载输出运算符，非成员函数，要声明成友元</span></span><br><span class="line">	os &lt;&lt; item.bookNo &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span> &lt;&lt; item.revenue;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>通常为成员函数，定义递增递减运算符的类应该同时定义前置版本和后置版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;<span class="keyword">operator</span>++() &#123;   <span class="comment">//重载前置运算符</span></span><br><span class="line">	(<span class="keyword">this</span>-&gt;units_sold)++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sales_data &amp;<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;   <span class="comment">//重载后置运算符，int形参唯一作用就是区分前置版本和后置版本</span></span><br><span class="line">	Sales_data ret = *<span class="keyword">this</span>;   <span class="comment">//记录当前值</span></span><br><span class="line">	++*<span class="keyword">this</span>;   <span class="comment">//调用重载的前置运算符</span></span><br><span class="line">	<span class="keyword">return</span> ret;   <span class="comment">//返回原值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales_data a;</span><br><span class="line">a.<span class="keyword">operator</span>++();   <span class="comment">//显示调用前置版本</span></span><br><span class="line">a.<span class="keyword">operator</span>++(<span class="number">0</span>);   <span class="comment">//显示调用后置版本</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;   <span class="comment">//重载函数调用运算符，求绝对值，注意后面是参数</span></span><br><span class="line">		<span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">absInt obj;</span><br><span class="line"><span class="keyword">int</span> ui = obj(<span class="number">-42</span>);   <span class="comment">//函数调用运算符，对象像一个函数</span></span><br></pre></td></tr></table></figure>

<p><strong>标准库 function 类型</strong></p>
<p>functiona 定义在 functional 头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统C函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; callableObject;   <span class="comment">//function 接受两个 int,返回一个 int 的可调用对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以赋值为传统C函数指针</span></span><br><span class="line">	callableObject = c_function;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; callableObject(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以赋值为函数对象</span></span><br><span class="line">	Functor functor;</span><br><span class="line">	callableObject = functor;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; callableObject(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以赋值为lambda表达式（特殊函数对象）</span></span><br><span class="line">	callableObject = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; callableObject(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>类型转换运算符是类的一种特殊成员函数，将一个类型的值转换成其他类型。除了显式地想 bool 类型的转换之外，我们应该尽量避免定义类型转换函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;   <span class="comment">//Sales_data 类隐式转换为 string 类型</span></span><br><span class="line"></span><br><span class="line">Sales_data c;</span><br><span class="line"><span class="built_in">string</span> str = c;   <span class="comment">//隐式类型转换</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/11/技术教程/C++/2017-1-11-第十一章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/11/技术教程/C++/2017-1-11-第十一章/" class="post-title-link" itemprop="url">第十一章 关联容器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-11T00:00:00+08:00">2017-01-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:05:57" itemprop="dateModified" datetime="2019-06-28T09:05:57+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器中元素是按关键字来保存和访问，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>map 是键值对，set 是集合。</p>
<p>map 和 multimap 定义在头文件 map 中，set 和 multiset 定义在头文件 set 中，无序容器则定义在头文件 unordered_map 和 unordered_set 中。</p>
<p>无论在有序容器中还是在无序容器中，具有相同关键字的元素都是相邻存储的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p><strong>定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; authors = &#123; &#123;<span class="string">"Joyce"</span>, <span class="string">"james"</span>&#125;,&#123;<span class="string">"Austen"</span> , <span class="string">"jane"</span>&#125; &#125;;   <span class="comment">//列表初始化</span></span><br></pre></td></tr></table></figure>

<p>一个 map 和 set 中的关键字必须是唯一的，multimap 和 multiset 没有此限制。</p>
<p><strong>pair 类型</strong></p>
<p>map 的元素是pair,pair 类型定义在 utility 头文件中，一个 pair 保存两个数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; authors&#123;<span class="string">"James"</span>, <span class="string">"Joyce"</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>map 中关键字是 const 的，我们不能通过迭代器改变其值。</p>
<p>用 insert 向关联容器中添加元素，返回一个 pair 类型，其中第一个元素指向该元素的 pair,第二个元素为 bool 类型，表示插入成功与否。</p>
<p>c.erase(k) 传递关键字为 k 的元素，返回实际删除的元素的数量。</p>
<p>c.erase(p) 传递一个迭代器或一个迭代器对来删除一个元素或者一个元素范围，返回实际删除的元素的数量。</p>
<p>与其他下标不同，如果关键字并不在 map 中，会为他创建一个元素并插入到 map 中。map 的下标返回一个左值，所以我们既可以读也可以写元素。</p>
<p>c.find(k) 返回一个迭代器，指向第一个关键字为 k 的元素（实际是一个 pair 类型）,若 k 不在容器中，则返回尾后迭代器。</p>
<p>c.count(k) 返回等于 k 的元素数量。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/10/技术教程/C++/2017-1-10-第十章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/10/技术教程/C++/2017-1-10-第十章/" class="post-title-link" itemprop="url">第十章 泛型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-10T00:00:00+08:00">2017-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:04:56" itemprop="dateModified" datetime="2019-06-28T09:04:56+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>可以用于不同类型的元素和多种容器类型的公共接口。大多数都定义在头文件 algorithm 中，在头文件 numeric 中定义了一组数值泛型算法。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作,不能（直接）添加或删除元素。</p>
<p>向目的位置迭代器写入数据的泛型算法（如 fill 算法）假定目的位置足够大，能够容纳要写入的元素。</p>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>==find 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = find(vec.cbegin(), vec.cend(), val);   <span class="comment">//如果在 vec 中查找到元素 val，则返回结果指向它，否则返回结果为 vec.cend()</span></span><br></pre></td></tr></table></figure>

<p>==count 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = count(vec.begin(), vec.end(), val);   <span class="comment">//返回给定值 val 在序列 vec 中出现的次数</span></span><br></pre></td></tr></table></figure>

<p>==accumulate 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = accumulate(vec.begin(), vec.end(), val);   <span class="comment">//对 vec 中的元素求和，第三个参数是和的初值</span></span><br></pre></td></tr></table></figure>

<p>==fill 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill(vec.begin(), vec.end(), val);   <span class="comment">//将 vec 中的元素填充为val</span></span><br></pre></td></tr></table></figure>

<p>==fill_n 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill_n(vec.begin(), n, val);   <span class="comment">//将 vec 中迭代器开始的n个元素填充为val</span></span><br></pre></td></tr></table></figure>

<p>==copy 与 unique_copy 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> al[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a1)/<span class="keyword">sizeof</span>(*a1)];   <span class="comment">//将 a2 设为与 a1 一样大</span></span><br><span class="line"><span class="keyword">auto</span> result = copy(begin(a1), end(a1), a2);   <span class="comment">//把 a1 的内容拷贝给 a2,result 指向拷贝到 a2 的尾元素之后的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = unique_copy(begin(a1), end(a1), a2);   <span class="comment">//只把 a1 的不重复元素拷贝给 a2</span></span><br></pre></td></tr></table></figure>

<p>==replace 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(vec.begin(), vec.end(), val1, val2);   <span class="comment">//将 vec 中所有值为 val1 的元素改为 val2</span></span><br></pre></td></tr></table></figure>

<p>==sort 与 unique 算法==</p>
<p>下面的例子实现消除 vector<string> 类型的 words 中重复单词的作用：</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(words.begin(), words.end());   <span class="comment">//对 words 按字母顺序进行排序</span></span><br><span class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(), words.end());   <span class="comment">//使不重复的元素出现在 vector 的开始部分，返回不重复区域之后一个位置的迭代器</span></span><br><span class="line">words.erase(end_unique, words.end());   <span class="comment">//使用容器的操作，正真删除重复操作</span></span><br></pre></td></tr></table></figure>

<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>主要是匿名函数 lambda 表达式，有如下形式：</p>
<p>*[captrue list](parameter list) -&gt; return type { function body }*</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [val](<span class="keyword">int</span> val2) &#123;<span class="keyword">return</span> val + val2; &#125;;   <span class="comment">//注意 f 相当于是函数名</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>用 bind 进行参数绑定。</p>
<p>==find_if 算法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vector中查找第一个大于string长度的值，这里还差一些头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;   <span class="comment">//可以使用所有的占位符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size_2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.size() &lt; sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; words = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">"string"</span>;</span><br><span class="line">	<span class="keyword">auto</span> check = bind(check_size_2, str, _1);   <span class="comment">//调用 check 时第一个参数传给 _1 占位符的位置，bind 的作用就是向 check_size 里传参数</span></span><br><span class="line">	<span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), check);   <span class="comment">//注意 find_if 函数是找到满足条件的第一个对象的迭代器</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *wc &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//用 * 解迭代器</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>标准库还在头文件 iteration 中定义了额外的几种迭代器。</p>
<p><strong>插入迭代器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; num1, num2, num3;</span><br><span class="line">copy(num.cbegin(), num.cend(), front_inserter(num1));   <span class="comment">//num3 是8，7，6，5，3，1</span></span><br><span class="line">copy(num.cbegin(), num.cend(), back_inserter(num2));</span><br><span class="line">copy(num.cbegin(), num.cend(), inserter(num3, num3.begin()));</span><br></pre></td></tr></table></figure>

<p><strong>iostream 迭代器</strong></p>
<p>istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; in_iter(<span class="built_in">cin</span>), eof;   <span class="comment">//读取输入流迭代器，从 cin 中读取 string，eof 是尾后迭代器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec(in_iter, eof);   <span class="comment">//用迭代器初始化 vector 对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="built_in">string</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);   <span class="comment">//向输出流中写数据迭代器，每个元素后加一个空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)   <span class="comment">//通过输出流迭代器循环打印</span></span><br><span class="line">	*out_iter++ = e;   <span class="comment">//运算符*和++实际上对ostream_iterator对象不做任何事，可以去掉,但推荐这种形式</span></span><br><span class="line"></span><br><span class="line">copy(vec.begin(), vec.end(), out_iter);   <span class="comment">//采用 copy 比循环简洁</span></span><br></pre></td></tr></table></figure>

<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>通用版本的 sort 要求随机访问迭代器，因此不能用于 list 和 forward_list。对于 list 和 forward_list 应优先使用成员函数而不是通用算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lst.merge(lst2);   <span class="comment">//将 lst2 中元素合并入 lst,lst 和 lst2 都必须有序</span></span><br><span class="line">lst.remove(val);   <span class="comment">//调用 erase 删除与给定值相等的每一个元素 </span></span><br><span class="line">lst.reverse();   <span class="comment">//反转 lst 中元素顺序</span></span><br><span class="line">lst.sort();   <span class="comment">//使用 &lt; 排序元素</span></span><br><span class="line">lst.unique();   <span class="comment">//调用 erase 删除同一个值的连续拷贝</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/09/技术教程/C++/2017-1-9-第九章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/09/技术教程/C++/2017-1-9-第九章/" class="post-title-link" itemprop="url">第九章 顺序容器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-09T00:00:00+08:00">2017-01-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:04:07" itemprop="dateModified" datetime="2019-06-28T09:04:07+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>顺序容器有如下几种类型：</p>
<ol>
<li>==vector== 可变大小数组</li>
<li>==deque== 双端队列</li>
<li>==list== 双向链表</li>
<li>==forward_list== 单向链表</li>
<li>==array== 固定大小数组，比内置数组类型更安全</li>
<li>==string== 与 vector 相似容器，专门保存字符</li>
</ol>
<p>通常情况下，vector 是最好的选择。</p>
<h2 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h2><p><strong>迭代器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin1 = v.begin();   <span class="comment">//iterator是此容器类型的迭代器类型</span></span><br><span class="line"><span class="keyword">auto</span> begin2 = v.begin();   <span class="comment">//用auto方便</span></span><br></pre></td></tr></table></figure>

<p>注意这里 begin() 还有两个版本，cbegin() 返回容器的 const_iterator 类型，当不需要写访问时使用。</p>
<p><strong>容器定义和初始化</strong></p>
<p>当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p>
<p>可以拷贝一个容器中的子序列：</p>
<pre><code>deque&lt;string&gt; copy(v.begin(), it);   //拷贝元素，直到（不包含）it指向的元素</code></pre><p>定义标准库 array 时，除了指定元素类型，还要指定容器大小。虽然我们不能对内置类型的数组进行拷贝，但 array 并无此限制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> digs[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> cpy[<span class="number">10</span>] = digs;   <span class="comment">//错误，内置类型不支持拷贝</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; digits = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; copy = digits;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><strong>赋值和 swap</strong></p>
<p>assign 允许我们从一个不同但相容的类型赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend());   <span class="comment">//可以将const char*转换为string</span></span><br><span class="line"></span><br><span class="line">seq.assign(b,e);   <span class="comment">//将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代其b,e不能指向seq中的元素</span></span><br><span class="line">seq.assign(n,t);   <span class="comment">//将seq中的元素替换为n个值为t的元素</span></span><br></pre></td></tr></table></figure>

<p>swap 交换两个相同类型容器的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec1(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2(<span class="number">24</span>);</span><br><span class="line">swap(svec1, svec2);</span><br></pre></td></tr></table></figure>

<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p><strong>向顺序容器添加元素</strong></p>
<p>有许多操作，但要注意这些操作对某些容器是不通用的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.push_front(t);   <span class="comment">//在c的头部添加元素</span></span><br><span class="line">c.insert(p, t);   <span class="comment">//在迭代器p指向的元素之前添加元素t,返回值恰好指向这个新元素</span></span><br><span class="line">c.emplace_back(<span class="string">"book1"</span>, <span class="number">2</span>, <span class="number">20</span>);   <span class="comment">//emplace函数在容器中直接构造元素,传入的参数必须与元素类型的构造函数相匹配</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">"book1"</span>, <span class="number">2</span>, <span class="number">20</span>));   <span class="comment">//创建一个临时对象传递给push_back，和上面一条语句等价</span></span><br></pre></td></tr></table></figure>

<p><strong>访问元素</strong></p>
<p>front 和 back 分别返回首元素与尾元素的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.front() = <span class="number">42</span>;   <span class="comment">//将42赋给c中第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> &amp;v = c.back;   <span class="comment">//获取指向最后一个元素的引用</span></span><br><span class="line">v = <span class="number">1024</span>;   <span class="comment">//改变c中的元素</span></span><br><span class="line"><span class="keyword">auto</span> v2 = c.back();   <span class="comment">//v2不是一个引用，是c.back()的一个拷贝</span></span><br><span class="line">v2 = <span class="number">0</span>;   <span class="comment">//不能改变c中的元素</span></span><br></pre></td></tr></table></figure>

<p><strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.pop_back();   <span class="comment">//删除c中尾元素</span></span><br><span class="line">c.pop_front;   <span class="comment">//删除c中首元素</span></span><br><span class="line">c.erase(p);   <span class="comment">//删除迭代器p所指定的元素，返回一个指向被删除元素之后元素的迭代器</span></span><br><span class="line">c.erase(b,e);   <span class="comment">//删除迭代器b和e所指定范围内的元素</span></span><br><span class="line">c.clear();   <span class="comment">//删除c中的所有元素</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊 forward_list 操作</strong></p>
<p>为单向链表，插入、删除元素时要用到前驱。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.before_begin();   <span class="comment">//返回首前迭代器，它的后继为链表第一个元素</span></span><br><span class="line">c.insert_after(p,t);   <span class="comment">//在p迭代器后插入一个元素，返回指向插入元素的迭代器</span></span><br><span class="line">c.erase_after(p);   <span class="comment">//删除p位置之后的元素，返回一个被删除元素之后的迭代器</span></span><br></pre></td></tr></table></figure>

<p><strong>容器操作可能使迭代器失效</strong></p>
<p>向容器中添加或删除元素的操作可能使指向容器元素的指针、引用或迭代器失效。如果在一个循环中插入删除元素，不要缓存end返回的迭代器，每次都要重新调用。</p>
<p><strong>vector 内存管理</strong></p>
<p>vector 和 string 通常会分配比新空间需求更大的内存空间。vector 采取的策略似乎为每次需要分配内存空间时将当前容量翻倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.capacity();   <span class="comment">//不重新分配内存空间的话，c可以保存多少元素</span></span><br><span class="line">c.reserve(n);   <span class="comment">//分配至少能容纳n个元素的内存空间,将capacity至少设定为n</span></span><br></pre></td></tr></table></figure>

<h2 id="额外-string-操作"><a href="#额外-string-操作" class="headerlink" title="额外 string 操作"></a>额外 string 操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos,n);   <span class="comment">//返回一个string，包含s中从pos开始的n个字符的拷贝</span></span><br><span class="line">s.append(args);   <span class="comment">//将args追加到s</span></span><br><span class="line">s.replace(range,args);   <span class="comment">//删除s中范围range内的字符，替换为args指定的字符</span></span><br><span class="line">s.find(args);   <span class="comment">//查找s中args第一次出现的位置</span></span><br><span class="line">s.find_first_of(args);   <span class="comment">//在s中查找args中任何一个字符第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(i);   <span class="comment">//将整数i转换为字符表示形式</span></span><br><span class="line"><span class="keyword">double</span> d = stod(s);   <span class="comment">//将字符串s转换为浮点数</span></span><br></pre></td></tr></table></figure>

<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样。stack 与 queue 都是基于 deque 实现的。</p>
<p>栈适配器 ==stack==</p>
<p>队列适配器 ==queue==</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/08/技术教程/C++/2017-1-8-第八章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/08/技术教程/C++/2017-1-8-第八章/" class="post-title-link" itemprop="url">第八章 IO库</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-08T00:00:00+08:00">2017-01-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:10:42" itemprop="dateModified" datetime="2019-06-28T09:10:42+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p><strong>IO类</strong></p>
<p>我们不能拷贝或对IO赋值。</p>
<p>刷新输出缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出一个换行符，并刷新输出缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; flush;   <span class="comment">//只刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; ends;   <span class="comment">//输出一个空字符，并刷新输出缓冲区</span></span><br></pre></td></tr></table></figure>

<p><strong>文件输入输出</strong></p>
<p>读文件在 ifstream 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(file_name)</span></span>;</span><br><span class="line">getline(in, str);   <span class="comment">//按每一行读取</span></span><br><span class="line">in &gt;&gt; str;   <span class="comment">//按每一个词读取</span></span><br></pre></td></tr></table></figure>

<p>写文件在 ofstream 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(file_name, ofstream::app)</span></span>;   <span class="comment">//以附加的方式打开写入文件</span></span><br><span class="line">out &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//直接写入到文件</span></span><br></pre></td></tr></table></figure>

<p><strong>string 流</strong></p>
<p>istringstream 从 string 中读取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;   <span class="comment">//将string类型的line绑定到record</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span> (record &gt;&gt; word)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>ostringstream 向 string 中写数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span> record;</span><br><span class="line">string a("hello"), b("world!");</span><br><span class="line">record &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; record.str() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//record.str()实际上返回的是string类型</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/07/技术教程/C++/2017-1-7-第七章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏雨潇潇">
      <meta itemprop="description" content="Hello world!">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="龙宇的博客小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/01/07/技术教程/C++/2017-1-7-第七章/" class="post-title-link" itemprop="url">第七章 类</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-07T00:00:00+08:00">2017-01-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 09:02:28" itemprop="dateModified" datetime="2019-06-28T09:02:28+08:00">2019-06-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>类有成员函数和作为接口组成部分的非成员函数，成员函数的声明必须在类内部，定义可以在类外部，非成员函数的定义和声明都在外部。</p>
<p>函数名后加 const 是常量成员函数，当调用对象的内容不需要改变时，尽量用常量成员函数。</p>
<p>成员函数体可以随意的使用类中的其他成员而无须在意这些成员函数的次序。</p>
<p>定义一个返回 this 对象的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span> </span>&#123;   <span class="comment">//注意是一个引用类型</span></span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数与类同名，没有返回类型，不能被声明成 const 类型，在 const 对象的构造过程中可以向其中写值。</p>
<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数，当定义其他构造函数时可以用 =default 手动生成默认构造函数。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>calss 与 struct 关键字唯一的区别就是默认访问权限，struct 的默认访问权限是 public，class 的默认访问权限是 private。</p>
<p>令其他类或函数成为类的友元，可以允许他们访问该类的非公有成员。</p>
<p>最好在类定义的开始或结尾集中声明友元，友元是在函数或类声明前加 friend。</p>
<p>友元的声明仅仅指定了访问权限，而非一个通常意义的函数声明。如果我们想使用这个函数，就必须在友元声明之外再专门对函数做一次声明。</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>用来定义类型的成员必须先定义再使用，这一点与其他普通成员有所区别，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;   <span class="comment">//pos是size_type类型的别名</span></span><br><span class="line">pos cursor = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>成员函数也可以被重载。</p>
<p>在成员前加 mutable 关键字定义成可变数据成员，永远不会是 const,即使在一个 const 对象内也能被修改。</p>
<p>最好只在类外部定义的地方说明 inline，这样可以使类方便理解。</p>
<p>一旦遇到类名，定义的剩余部分就在类的作用域之内，包括参数列表和函数体。</p>
<p>类型名的定义通常出现在类的开始，这样就能确保使用该类型的成员都能出现在类名的定义之后。</p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><p>习惯于使用构造函数初始值，如果成员是 const、引用，我们必须通过构造函数初始值列表为这些成员提供初值。</p>
<p>成员实际初始化顺序与他们在类定义中的出现顺序一样，构造函数初始值列表中初始值前后顺序不影响实际初始化顺序，最好令构造函数初始值顺序与成员声明一致。</p>
<p>如果一个构造函数为所有（部分）参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>在成员前加 static 关键字，可以是 public 或 private 的。</p>
<p>虽然不属于类的某个对象，但是我们可以使用类的对象、引用或指针来访问静态成员。</p>
<p>静态成员可以作为默认实参。</p>
<p>可以在类的内部或者外部定义静态成员，但是必须在类的外部初始化。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="夏雨潇潇">
            
              <p class="site-author-name" itemprop="name">夏雨潇潇</p>
              <div class="site-description motion-element" itemprop="description">Hello world!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏雨潇潇</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
